<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Untitled RSS Feed]]></title><description><![CDATA[Untitled RSS Feed]]></description><link>https://ciena-blueplanet.github.io/developers.blog</link><generator>RSS for Node</generator><lastBuildDate>Fri, 19 May 2017 18:02:16 GMT</lastBuildDate><atom:link href="https://ciena-blueplanet.github.io/developers.blog/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Faster acceptance tests]]></title><description><![CDATA[<div class="paragraph">
<p>You may have noticed that when working with <code>ember-cli-mocha</code>, acceptance tests created with</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ember g acceptance-test &lt;name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Can run rather slowly if you use proper BDD ettiquette and include an <code>it()</code> for every <code>expect()</code>. This is due primarily to the fact that the application is created in a top-level <code>beforeEach()</code> and destroyed in a top-level <code>afterEach()</code> While this makes your tests very nicely independent, it can also make your tests rather slow, since the app is created and your route rendererd independently for each <code>it()</code>.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re like me, you often set up a scenario in your <code>beforeEach()</code> and then have a few different things you want to verify expected behavior for, without changing the state of your application. In cases like those, what you really want is <code>before()</code> and <code>after()</code> instead of <code>beforeEach()</code> and <code>afterEach()</code>. Inside a <code>describe()</code>, <code>before()</code> is executed once, then all the <code>it()</code> methods are executed, then the <code>after()</code> is executed once. On the other hand, as the name suggests <code>beforeEach()</code> is exectued before each individual <code>it()</code> method and <code>afterEach()</code> is executed after each individual <code>it()</code> method.</p>
</div>
<div class="paragraph">
<p>So, what happens when the following test is run?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import {afterEach, beforeEach, describe, it} from 'mocha'
import {expect} from 'chai'
import startApp from '../../../helpers/start-app'
import destroyApp from '../../../helpers/destroy-app'

describe('Acceptance: Login page shows form', function () {
  let application

  beforeEach(function () {
    application = startApp()
    visit('/login')
  })

  afterEach(function () {
    destroyApp(application)
  })

  it('should display the company logo', function () {
    expect(find('img.logo')).to.have.length(1)
  })

  it('should display a username input', function () {
    expect(find('input[type=text].username')).to.have.length(1)
  })

  it('should display a password input', function () {
    expect(find('input[type=password].password')).to.have.length(1)
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Well, since we&#8217;re using the default <code>beforeEach()</code> to perform the <code>startApp()</code> call, and we have 3 <code>it()</code> methods, the app is being created 3 times, and each time a single expectation is being verified.</p>
</div>
<div class="paragraph">
<p>Now, you may be thinking, if I want to speed that up, all I have to do is combine the <code>it()</code> methods. After all, <code>beforeEach()</code> will run once for each <code>it()</code>, so if I only want it to run once, I should just have a single <code>it()</code>.</p>
</div>
<div class="paragraph">
<p>Seems logical&#8230;&#8203; right?</p>
</div>
<div class="paragraph">
<p>Wrong.</p>
</div>
<div class="paragraph">
<p>Don&#8217;t do that.</p>
</div>
<div class="paragraph">
<p>No one wants to see this test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import {afterEach, beforeEach, describe, it} from 'mocha'
import {expect} from 'chai'
import startApp from '../../../helpers/start-app'
import destroyApp from '../../../helpers/destroy-app'

describe('Acceptance: Login page shows form', function () {
  let application

  beforeEach(function () {
    application = startApp()
    visit('/login')
  })

  afterEach(function () {
    destroyApp(application)
  })

  it('should render the logo and login form', function () {
    expect(find('img.logo')).to.have.length(1)
    expect(find('input[type=text].username')).to.have.length(1)
    expect(find('input[type=password].password')).to.have.length(1)
  })
})</code></pre>
</div>
</div>
<div class="olist arabic">
<div class="title">And here&#8217;s why:</div>
<ol class="arabic">
<li>
<p>It doesn&#8217;t read well.</p>
</li>
<li>
<p>Failures are difficult to track down</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Sure, you can try to mitigate #2 by doing something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import {afterEach, beforeEach, describe, it} from 'mocha'
import {expect} from 'chai'
import startApp from '../../../helpers/start-app'
import destroyApp from '../../../helpers/destroy-app'

describe('Acceptance: Login page shows form', function () {
  let application

  beforeEach(function () {
    application = startApp()
    visit('/login')
  })

  afterEach(function () {
    destroyApp(application)
  })

  it('should render the logo and login form', function () {
    expect(
      find('img.logo'),
      'the logo should be shown'
    ).to.have.length(1)

    expect(
      find('input[type=text].username'),
      'the username input should be shown'
    ).to.have.length(1)

    expect(
      find('input[type=password].password'),
      'the password input should be shown'
    ).to.have.length(1)
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>But really, you can&#8217;t honestly tell me that&#8217;s easy to read/follow.</p>
</div>
<div class="paragraph">
<p>Instead, embrace the power of <code>before()</code> and speed up your test without losing readability or ease of debugging:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-js" data-lang="js">import {after, before, describe, it} from 'mocha'
import {expect} from 'chai'
import startApp from '../../../helpers/start-app'
import destroyApp from '../../../helpers/destroy-app'

describe('Acceptance: Login page shows form', function () {
  let application

  before(function () {
    application = startApp()
    visit('/login')
  })

  after(function () {
    destroyApp(application)
  })

  it('should display the company logo', function () {
    expect(find('img.logo')).to.have.length(1)
  })

  it('should display a username input', function () {
    expect(find('input[type=text].username')).to.have.length(1)
  })

  it('should display a password input', function () {
    expect(find('input[type=password].password')).to.have.length(1)
  })
})</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now what&#8217;s happening. Well, since <code>before()</code> runs before <strong>all</strong> <code>it()</code> methods, and <code>after()</code> runs after <strong>all</strong> <code>it()</code> methods, we have a single app instance being created, and then three expectations happening before the app instance is destroyed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>WARNING</strong>: Creating your app in <code>before()</code> means that all your nested functionality is using the same app, with the same state. So, if you click a check-box in one test, it&#8217;ll stay clicked for the next test unless you reset your state somehow!
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>The above limitation means you have two options when writing acceptance tests, since I don&#8217;t consider having to clean up after yourself after every interaction with your app a valid option.</p>
</div>
<div class="paragraph">
<p>The first option is to create a new <code>describe()</code> with it&#8217;s own <code>startApp()</code> and <code>destroyApp()</code> for each interaction you want to test. This is a valid option in many situations, but may not be as desirable in others.</p>
</div>
<div class="paragraph">
<p>The second option is to use another mechanism to reset your state to a known starting point before beginning to interact with your application. For instance, you could use <code>visit()</code> to navigate to another route (preferably a very easy to load one, like <code>not-found</code>) and then navigate back to the current route (effectively doing a refresh).</p>
</div>
</div>
</div>]]></description><link>https://ciena-blueplanet.github.io/developers.blog/2016/08/24/Faster-acceptance-tests.html</link><guid isPermaLink="true">https://ciena-blueplanet.github.io/developers.blog/2016/08/24/Faster-acceptance-tests.html</guid><category><![CDATA[mocha]]></category><category><![CDATA[ ember]]></category><category><![CDATA[ testing]]></category><category><![CDATA[ acceptance]]></category><dc:creator><![CDATA[Adam Meadows]]></dc:creator><pubDate>Wed, 24 Aug 2016 00:00:00 GMT</pubDate></item></channel></rss>